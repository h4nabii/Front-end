<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body, ul, li {
            margin: 0;
            padding: 0;
        }

        li {
            list-style: none;
        }

        .menu {
            background: rgb(86, 134, 12);
            height: 38px;
            line-height: 38px;
        }

        .menu ul li {
            text-align: center;
            float: left;
            width: 110px;
            height: 38px;
            line-height: 38px;
            border-right: 1px solid cyan;
        }

        .menu ul li:hover {
            background: orangered;
        }

        .menu ul li a {
            text-decoration: none;
            color: #fff;
        }

        .sub-nav {
            width: 110px;
            margin-top: 10px;
            background: orange;
            overflow: hidden;
            display: none;
        }

        .sub-nav span {
            float: left;
            width: 100px;
            height: 30px;
            line-height: 30px;
        }

        .sub-nav span:hover {
            background: #335599;
            color: #fff;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div class="menu">
    <ul>
        <li>
            <a href>公司简介</a>
            <div class="sub-nav">
                <span>学习一</span>
                <span>学习一</span>
                <span>学习一</span>
                <span>学习一</span>
                <span>学习一</span>
            </div>
        </li>
        <li>
            <a href>公司简介</a>
            <div class="sub-nav">
                <span>学习一</span>
                <span>学习二</span>
                <span>学习二</span>
                <span>学习二</span>
                <span>学习二</span>
            </div>
        </li>
        <li>
            <a href>公司简介</a>
            <div class="sub-nav">
                <span>学习三</span>
                <span>学习三</span>
                <span>学习三</span>
                <span>学习三</span>
                <span>学习三</span>
            </div>
        </li>
        <li>
            <a href>公司简介</a>
        </li>
        <li>
            <a href>公司简介</a>
        </li>
        <li>
            <a href>公司简介</a>
        </li>
        <li>
            <a href>公司简介</a>
        </li>
    </ul>
</div>
</body>
</html>
<script>

    const oLis = document.querySelectorAll('.menu li');

    // const allSubNav = document.querySelectorAll('.menu .sub-nav');

    /*
    * 无需在 sub-nav 上处理事件
    *
    * 一方面，若使用 onmouseover，sub-nav 的 onmouseover 事件会冒泡到 <li> 上，
    * 而 sub-nav 的内部空间完全被 <li> 包围，sub-nav 的 onmouseenter 的触发范围小于等于 <li> 的 onmouseenter 的触发范围，
    * 可以只在通过 <li> 处理 onmouseover 事件
    *
    * 另一方面，仅在 sub-nav 上设置 clearTimeout，在当前情景（sub-nav 与 <li> 存在距离）会导致一个 bug：
    * 当从 sub-nav 快速（小于200ms，即设定的 timeout 时长）移回到所属的 <li> 上时仍然会触发 sub-nav 的收起
    *
    * 原因：当从 sub-nav 离开时会同时触发 sub-nav 和 <li> 的 onmouseleave/onmouseout 从而设置 200ms 的 timeout，
    * 在 sub-nav 消失前，鼠标回到 <li> 上时，display 先设置为 block （未改变），
    * 之后计时器结束，display 又设置为 none，导致鼠标虽然在 <li> 上但是 sub-nav 依然收起
    *
    * 直接的解决方法是在 <li> 上合理的设置 clearTimeout，这就与 sub-nav 的 clearTimeout 功能重合，
    * 所以没有必要在 sub-nav 上设置 clearTimeout，而是直接在 <li> 上进行事件处理
    *  */

    // let tid = null;
    /*
    * 将全局的 tid 改变为内部变量储存在 oLis 的每个对象的内部以确保不会丢失控制
    * （确保应用于于同一个 <li> 的旧 ID 不会被新 ID 覆盖）
    * 也可以将所有的 ID 通过数组保存
    * */

    for (let li of oLis) {
        li.onmouseenter = function () {
            /*
            * 可能存在 selector 找不到元素的情况
            * 即 ul li 下不存在 class 为 sub-nav 的元素
            * 第 4-7 个 <li>
            * */
            let subNav = this.querySelector('.sub-nav');
            if (subNav) subNav.style.display = 'block';

            /*
            * 使用 clearTimeout 清除 callback 函数的触发
            * clearTimeout 和 clearInterval 共用 id 故两者均有效
            *
            * > 引用自 https://developer.mozilla.org/zh-CN/docs/Web/API/clearInterval
            * > 值得一提的是，setInterval() 和 setTimeout() 共用其定义的 IDs，
            * > 即可以使用 clearInterval() 和 clearTimeout() 中的任意一个。
            * > 然而，为了使代码可读性更强，你应该尽量避免这种用法。
            *
            * 重新进入 <li> 时需要清除之前的计时器
            * */
            clearTimeout(this.tid);
        }

        /* Old code */
        // oLis[i].onmouseout = function () {
        //     /* console.log(this) => <li> */
        //     tid = setTimeout(function () {
        //         /* console.log(this) => window */
        //         this.querySelector('.sub-nav').style.display = 'none';
        //     }, 200)
        // }

        /*
        * onmouseout 在鼠标移到 <a> 标签上时会触发，同时 <a> 的 onmouseover 事件会冒泡到 <li> 上触发 <li> 的 onmouseover，
        * 此时倘若未在 <li> 上 清除 onmouseover 设置的 timeout 会导致 sub-nav 收起。
        *
        * 而如果在 <li> 上设置 clearTimeout，则有必要为每个 <li> 分配一个 tid，否则会出现一个 bug：
        * 当从一个 <li> 水平移动到另一个 <li> 上，离开前一个 <li> 时会触发 setTimeout，
        * 但进入新的 <li> 后会立马触发 clearTimeout 清除离开前一个 <li> 时设置的 timeout，
        * 导致前一个 <li> 下属的 sub-nav 无法被正确收起。
        *
        * 所以要么在 <li> 上合理的清除 timeout，要么使用 onmouseleave 避免移动到 <a> 元素上时触发 onmouseout 事件
        *
        * over  <->  out
        * enter <->  leave
        * PS：enter 和 leave 不会触发事件冒泡
        * 引用自 https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseenter_event
        * 尽管与 mouseover 类似，但是 mouseenter 的不同之处在于
        * 当鼠标指针从它后代的物理空间移动到它自己的物理空间时，它不会冒泡，也不会发送给它的任何后代。
        * */
        li.onmouseleave = function () {
            /*
            * 此处样式设定失效是因为 setTimeout 中的 this 指向与回调中的指向不同，为 window 对象
            * 有多种解决方法
            * 1、直接将 this 修改为 li (oLis[i])
            * 2、重新绑定 this 的指向
            * 3、使用不同的 id 区分多个 sub-nav 随后使用 document 的 id 选择器选择对应 sub-nav
            * 4、使用 querySelectorAll 获取全部 sub-nav 后选择对应的 sub-nav
            * */

            /* 使用 bind 强制将 this 绑定到对应的 <li> 上 */
            let callback = (function () {
                let subNav = this.querySelector('.sub-nav');
                if (subNav) subNav.style.display = 'none';
            }).bind(this);

            /* this 指向 <li> */
            this.tid = setTimeout(callback, 200)
        }
    }
</script>
